
```{r include = FALSE}
source("../tools/chunk-options.R")
```

# Control flow

```{r, include=FALSE}
# Silently load in the data so the rest of the lesson works
titanic <- read.csv("https://goo.gl/4Gqsnz", header=TRUE)
# Silently set seed for random number generation, so we don't have to explain it
set.seed(10)
```

<!--sec data-title="Learning Objectives" data-id="obj" data-show=true data-collapse=false ces-->

* Write conditional statements with `if` and `else`.
* Write and understand `for` loops.

<!--endsec-->

<br>

---

**Table of Contents**

<!-- toc -->

<br>

---

## Conditionals

Often when we're coding we want to control the flow of our actions. This can be done
by setting actions to occur only if a condition or a set of conditions are met.
Alternatively, we can also set an action to occur a particular number of times.

There are several ways you can control flow in R.
For conditional statements, the most commonly used approaches are the constructs:

```{r, eval=FALSE}
# if
if (condition is true) {
  perform action
}

# if ... else
if (condition is true) {
  perform action
} else {  # that is, if the condition is false,
  perform alternative action
}
```

Say, for example, that we want R to print a message if a variable `x` has a particular value:

```{r}
# sample a random number from a Poisson distribution
# with a mean (lambda) of 8

x <- rpois(1, lambda=8)

if (x >= 10) {
  print("x is greater than or equal to 10")
}

x
```

Note you may not get the same output as your neighbour because
you may be sampling different random numbers from the same distribution.

Let's set a seed so that we all generate the same 'pseudo-random'
number, and then print more information:

```{r}
x <- rpois(1, lambda=8)

if (x >= 10) {
  print("x is greater than or equal to 10")
} else if (x > 5) {
  print("x is greater than 5")
} else {
  print("x is less than 5")
}
```

<!--sec data-title="Tip: Pseudo-random numbers" data-id="tip1" data-show=true data-collapse=true ces-->

In the above case, the function `rpois` generates a random number following a Poisson distribution with a mean (i.e. lambda) of 8. The function `set.seed` guarantees that all machines will generate the exact same 'pseudo-random' number ([more about pseudo-random numbers](http://en.wikibooks.org/wiki/R_Programming/Random_Number_Generation)).
So if we `set.seed(10)`, we see that `x` takes the value 8. You should get the exact same number.

<!--endsec-->

**Important:** when R evaluates the condition inside `if` statements, it is
looking for a logical element, i.e., `TRUE` or `FALSE`. This can cause some
headaches for beginners. For example:

```{r}
x  <-  4 == 3
if (x) {
  "4 equals 3"
}
```

As we can see, the message was not printed because the vector x is `FALSE`

```{r}
x <- 4 == 3
x
```

<!--sec data-title="Challenge 1" data-id="ch1" data-show=true data-collapse=false ces-->

Use an `if` statement to print a suitable message reporting whether there are any people with age of 100 in the `titanic` dataset. Now do the same for 80. HINT: you will need to use the na.rm argument in the `any()` function.

<!--endsec-->

Did anyone get a warning message like this?

```{r, echo=FALSE}
try(err <- {if (titanic$Age == 100) {}})
```

If your condition evaluates to a vector with more than one logical element,
the function `if` will still run, but will only evaluate the condition in the first
element. Here you need to make sure your condition is of length 1.

<!--sec data-title="Tip: any and all" data-id="tip2" data-show=true data-collapse=true ces-->

The `any` function will return TRUE if at least one TRUE value is found within a vector, otherwise it will return `FALSE`. This can be used in a similar way to the `%in%` operator. The function `all`, as the name suggests, will only return `TRUE` if all values in the vector are `TRUE`.

<!--endsec-->

<br>

---

## Repeating operations

 

If you want to iterate over
a set of values, when the order of iteration is important, and perform the
same operation on each, a `for` loop will do the job.
We saw `for` loops in the shell lessons earlier. This is the most
flexible of looping operations, but therefore also the hardest to use
correctly. Avoid using `for` loops unless the order of iteration is important:
i.e. the calculation at each iteration depends on the results of previous iterations.

The basic structure of a `for` loop is:

```{r, eval=FALSE}
for(iterator in set of values){
  do a thing
}
```

For example:

```{r}
for(i in 1:10){
  print(i)
}
```

The `1:10` bit creates a vector on the fly; you can iterate
over any other vector as well.

We can use a `for` loop nested within another `for` loop to iterate over two things at
once.

```{r}
for (i in 1:5){
  for(j in c('a', 'b', 'c', 'd', 'e')){
    print(paste(i,j))
  }
}
```

Rather than printing the results, we could write the loop output to a new object.

```{r}
output_vector <- c()
for (i in 1:5){
  for(j in c('a', 'b', 'c', 'd', 'e')){
    temp_output <- paste(i, j)
    output_vector <- c(output_vector, temp_output)
  }
}
output_vector
```

This approach can be useful, but 'growing your results' (building
the result object incrementally) is computationally inefficient, so avoid
it when you are iterating through a lot of values.

<!--sec data-title="Tip: Don't grow your results" data-id="tip3" data-show=true data-collapse=true ces-->

One of the biggest things that trips up novices and experienced R users alike, is building a results object (vector, list, matrix, data frame) as your for loop progresses. Computers are very bad at handling this, so your calculations can very quickly slow to a crawl. It's much better to define an empty results object before hand of the appropriate dimensions. So if you know the end result will be stored in a matrix like above, create an empty matrix with 5 row and 5 columns, then at each iteration store the results in the appropriate location.

<!--endsec-->

A better way is to define your (empty) output object before filling in the values.
For this example, it looks more involved, but is still more efficient.

```{r}
output_matrix <- matrix(nrow=5, ncol=5)
j_vector <- c('a', 'b', 'c', 'd', 'e')
for (i in 1:5){
  for(j in 1:5){
    temp_j_value <- j_vector[j]
    temp_output <- paste(i, temp_j_value)
    output_matrix[i, j] <- temp_output
  }
}
output_vector2 <- as.vector(output_matrix)
output_vector2
```

<!--sec data-title="Tip: While loops" data-id="tip4" data-show=true data-collapse=true ces-->

Sometimes you will find yourself needing to repeat an operation until a certain condition is met. You can do this with a `while` loop.

```{r, eval=FALSE}
while(this condition is true){
   do a thing
}
```
 
As an example, here's a while loop  that generates random numbers from a uniform distribution (the `runif` function) between 0 and 1 until it gets one that's less than 0.1.

~~~ {.r}
z <- 1
while(z > 0.1){
   z <- runif(1)
   print(z)
}
~~~
 
`while` loops will not always be appropriate. You have to be particularly careful that you don't end up in an infinite loop because your condition is never met.

<!--endsec-->

<!--sec data-title="Challenge 2" data-id="ch2" data-show=true data-collapse=false ces-->

Compare the objects output_vector and output_vector2. Are they the same? If not, why not? How would you change the last block of code to make output_vector2 the same as output_vector?

<!--endsec-->

<!--sec data-title="Challenge 3" data-id="ch3" data-show=true data-collapse=false ces-->

Write a script that loops through the `titanic` data by passenger class and prints  out whether the mean Survived measure is smaller or larger than 0.5. Hint: you may want to check out the function unique().

<!--endsec-->

<!--sec data-title="Challenge 4" data-id="ch4" data-show=true data-collapse=false ces-->

Modify the script from Challenge 4 to also loop over each sex. This time print out whether the Survived is smaller than 0.2, between 0.2 and 0.6, or greater than 0.6.

<!--endsec-->

<br>

---

## Challenge solutions

<!--sec data-title="Solution to Challenge 1" data-id="ch1sol" data-show=true data-collapse=true ces-->

Use an `if` statement to print a suitable message reporting whether there are any people with age of 100 in the `titanic` dataset. Now do the same for 80.

```{r}
if (any(titanic$Age == 100, na.rm = TRUE)){
  print("There was at least one 100 y.o. person in the dataset")
} else {
  print("There were no 100 y.o. persons in the dataset")
}
if (any(titanic$Age == 80, na.rm = TRUE)){
  print("There was at least one 80 y.o. person in the dataset")
} else {
  print("There were no 80 y.o. persons in the dataset")
}
```

<!--endsec-->

<!--sec data-title="Solution to Challenge 2" data-id="ch2sol" data-show=true data-collapse=true ces-->

Compare the objects output_vector and output_vector2. Are they the same? If not, why not? How would you change the last block of code to make output_vector2 the same as output_vector?

The rows and columns have been swapped between output_vector and output_vector2
```{r}
output_matrix <- matrix(nrow=5, ncol=5)
j_vector <- c('a', 'b', 'c', 'd', 'e')
for (i in 1:5){
  for(j in 1:5){
    temp_j_value <- j_vector[j]
    temp_output <- paste(i, temp_j_value)
    output_matrix[j, i] <- temp_output
  }
}
output_vector2 <- as.vector(output_matrix)
output_vector2
```

<!--endsec-->

<!--sec data-title="Solution to Challenge 3" data-id="ch3sol" data-show=true data-collapse=true ces-->

Write a script that loops through the `titanic` data by passenger class and prints  out whether the mean Survived measure is smaller or larger than 0.5. Hint: you may want to check out the function unique().

```{r}
for (class in sort(unique(titanic$Pclass))){
  if (mean(titanic$Survived[titanic$Pclass == class]) > 0.5){
  print(paste("The mean Survived measure for people with class", class, "is greater than 0.5 units"))
  } else {
  print(paste("The mean Survived measure for people with class", class, "is less than 0.5 units"))
  }
}
```

<!--endsec-->

<!--sec data-title="Solution to Challenge 4" data-id="ch4sol" data-show=true data-collapse=true ces-->

Modify the script from Challenge 4 to also loop over each sex. This time print out whether the Survived is smaller than 0.2, between 0.2 and 0.6, or greater than 0.6.

```{r}
for (class in sort(unique(titanic$Pclass))){
  for (sex in unique(titanic$Sex)) {
    if (mean(titanic$Survived[titanic$Pclass == class & titanic$Sex == sex]) <= 0.2){
      print(paste("The mean Survived measure for",sex,"people with class", class, "is less than 0.2 units"))
    } else if (mean(titanic$Survived[titanic$Pclass == class & titanic$Sex == sex]) > 0.6) {
      print(paste("The mean Survived measure for",sex,"people with class", class, "is greater than 0.6 units"))
    } else {
      print(paste("The mean Survived measure for",sex,"people with class", class, "is between 0.2 and 0.6"))
    }
  }
}
```
<!--endsec-->